/* automatically generated by rust-bindgen 0.70.1 */

pub const _STDINT_H: u32 = 1;
pub const _FEATURES_H: u32 = 1;
pub const _DEFAULT_SOURCE: u32 = 1;
pub const __GLIBC_USE_ISOC23: u32 = 0;
pub const __USE_ISOC11: u32 = 1;
pub const __USE_ISOC99: u32 = 1;
pub const __USE_ISOC95: u32 = 1;
pub const __USE_POSIX_IMPLICITLY: u32 = 1;
pub const _POSIX_SOURCE: u32 = 1;
pub const _POSIX_C_SOURCE: u32 = 200809;
pub const __USE_POSIX: u32 = 1;
pub const __USE_POSIX2: u32 = 1;
pub const __USE_POSIX199309: u32 = 1;
pub const __USE_POSIX199506: u32 = 1;
pub const __USE_XOPEN2K: u32 = 1;
pub const __USE_XOPEN2K8: u32 = 1;
pub const _ATFILE_SOURCE: u32 = 1;
pub const __WORDSIZE: u32 = 64;
pub const __WORDSIZE_TIME64_COMPAT32: u32 = 1;
pub const __SYSCALL_WORDSIZE: u32 = 64;
pub const __TIMESIZE: u32 = 64;
pub const __USE_TIME_BITS64: u32 = 1;
pub const __USE_MISC: u32 = 1;
pub const __USE_ATFILE: u32 = 1;
pub const __USE_FORTIFY_LEVEL: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_GETS: u32 = 0;
pub const __GLIBC_USE_DEPRECATED_SCANF: u32 = 0;
pub const __GLIBC_USE_C23_STRTOL: u32 = 0;
pub const _STDC_PREDEF_H: u32 = 1;
pub const __STDC_IEC_559__: u32 = 1;
pub const __STDC_IEC_60559_BFP__: u32 = 201404;
pub const __STDC_IEC_559_COMPLEX__: u32 = 1;
pub const __STDC_IEC_60559_COMPLEX__: u32 = 201404;
pub const __STDC_ISO_10646__: u32 = 201706;
pub const __GNU_LIBRARY__: u32 = 6;
pub const __GLIBC__: u32 = 2;
pub const __GLIBC_MINOR__: u32 = 40;
pub const _SYS_CDEFS_H: u32 = 1;
pub const __glibc_c99_flexarr_available: u32 = 1;
pub const __LDOUBLE_REDIRECTS_TO_FLOAT128_ABI: u32 = 0;
pub const __HAVE_GENERIC_SELECTION: u32 = 1;
pub const __GLIBC_USE_LIB_EXT2: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_BFP_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT: u32 = 0;
pub const __GLIBC_USE_IEC_60559_FUNCS_EXT_C23: u32 = 0;
pub const __GLIBC_USE_IEC_60559_TYPES_EXT: u32 = 0;
pub const _BITS_TYPES_H: u32 = 1;
pub const _BITS_TYPESIZES_H: u32 = 1;
pub const __OFF_T_MATCHES_OFF64_T: u32 = 1;
pub const __INO_T_MATCHES_INO64_T: u32 = 1;
pub const __RLIM_T_MATCHES_RLIM64_T: u32 = 1;
pub const __STATFS_MATCHES_STATFS64: u32 = 1;
pub const __KERNEL_OLD_TIMEVAL_MATCHES_TIMEVAL64: u32 = 1;
pub const __FD_SETSIZE: u32 = 1024;
pub const _BITS_TIME64_H: u32 = 1;
pub const _BITS_WCHAR_H: u32 = 1;
pub const _BITS_STDINT_INTN_H: u32 = 1;
pub const _BITS_STDINT_UINTN_H: u32 = 1;
pub const _BITS_STDINT_LEAST_H: u32 = 1;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i64 = -9223372036854775808;
pub const INT_FAST32_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u64 = 9223372036854775807;
pub const INT_FAST32_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: i32 = -1;
pub const UINT_FAST32_MAX: i32 = -1;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const UINTPTR_MAX: i32 = -1;
pub const PTRDIFF_MIN: i64 = -9223372036854775808;
pub const PTRDIFF_MAX: u64 = 9223372036854775807;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const SIZE_MAX: i32 = -1;
pub const WINT_MIN: u32 = 0;
pub const WINT_MAX: u32 = 4294967295;
pub const READ_BATCH_ROW_INFO_VERSION_0: u32 = 0;
pub const READ_BATCH_ROW_INFO_VERSION_1: u32 = 1;
pub const READ_BATCH_ROW_INFO_VERSION_2: u32 = 2;
pub const READ_BATCH_ROW_INFO_VERSION_3: u32 = 3;
pub const READ_BATCH_ROW_INFO_VERSION: u32 = 3;
pub type wchar_t = ::std::os::raw::c_int;
#[repr(C)]
#[repr(align(16))]
#[derive(Debug, Copy, Clone)]
pub struct max_align_t {
    pub __clang_max_align_nonce1: ::std::os::raw::c_longlong,
    pub __bindgen_padding_0: u64,
    pub __clang_max_align_nonce2: u128,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of max_align_t"][::std::mem::size_of::<max_align_t>() - 32usize];
    ["Alignment of max_align_t"][::std::mem::align_of::<max_align_t>() - 16usize];
    [
        "Offset of field: max_align_t::__clang_max_align_nonce1",
    ][::std::mem::offset_of!(max_align_t, __clang_max_align_nonce1) - 0usize];
    [
        "Offset of field: max_align_t::__clang_max_align_nonce2",
    ][::std::mem::offset_of!(max_align_t, __clang_max_align_nonce2) - 16usize];
};
pub type __u_char = ::std::os::raw::c_uchar;
pub type __u_short = ::std::os::raw::c_ushort;
pub type __u_int = ::std::os::raw::c_uint;
pub type __u_long = ::std::os::raw::c_ulong;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub type __int_least8_t = __int8_t;
pub type __uint_least8_t = __uint8_t;
pub type __int_least16_t = __int16_t;
pub type __uint_least16_t = __uint16_t;
pub type __int_least32_t = __int32_t;
pub type __uint_least32_t = __uint32_t;
pub type __int_least64_t = __int64_t;
pub type __uint_least64_t = __uint64_t;
pub type __quad_t = ::std::os::raw::c_long;
pub type __u_quad_t = ::std::os::raw::c_ulong;
pub type __intmax_t = ::std::os::raw::c_long;
pub type __uintmax_t = ::std::os::raw::c_ulong;
pub type __dev_t = ::std::os::raw::c_ulong;
pub type __uid_t = ::std::os::raw::c_uint;
pub type __gid_t = ::std::os::raw::c_uint;
pub type __ino_t = ::std::os::raw::c_ulong;
pub type __ino64_t = ::std::os::raw::c_ulong;
pub type __mode_t = ::std::os::raw::c_uint;
pub type __nlink_t = ::std::os::raw::c_ulong;
pub type __off_t = ::std::os::raw::c_long;
pub type __off64_t = ::std::os::raw::c_long;
pub type __pid_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __fsid_t {
    pub __val: [::std::os::raw::c_int; 2usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of __fsid_t"][::std::mem::size_of::<__fsid_t>() - 8usize];
    ["Alignment of __fsid_t"][::std::mem::align_of::<__fsid_t>() - 4usize];
    [
        "Offset of field: __fsid_t::__val",
    ][::std::mem::offset_of!(__fsid_t, __val) - 0usize];
};
pub type __clock_t = ::std::os::raw::c_long;
pub type __rlim_t = ::std::os::raw::c_ulong;
pub type __rlim64_t = ::std::os::raw::c_ulong;
pub type __id_t = ::std::os::raw::c_uint;
pub type __time_t = ::std::os::raw::c_long;
pub type __useconds_t = ::std::os::raw::c_uint;
pub type __suseconds_t = ::std::os::raw::c_long;
pub type __suseconds64_t = ::std::os::raw::c_long;
pub type __daddr_t = ::std::os::raw::c_int;
pub type __key_t = ::std::os::raw::c_int;
pub type __clockid_t = ::std::os::raw::c_int;
pub type __timer_t = *mut ::std::os::raw::c_void;
pub type __blksize_t = ::std::os::raw::c_long;
pub type __blkcnt_t = ::std::os::raw::c_long;
pub type __blkcnt64_t = ::std::os::raw::c_long;
pub type __fsblkcnt_t = ::std::os::raw::c_ulong;
pub type __fsblkcnt64_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt_t = ::std::os::raw::c_ulong;
pub type __fsfilcnt64_t = ::std::os::raw::c_ulong;
pub type __fsword_t = ::std::os::raw::c_long;
pub type __ssize_t = ::std::os::raw::c_long;
pub type __syscall_slong_t = ::std::os::raw::c_long;
pub type __syscall_ulong_t = ::std::os::raw::c_ulong;
pub type __loff_t = __off64_t;
pub type __caddr_t = *mut ::std::os::raw::c_char;
pub type __intptr_t = ::std::os::raw::c_long;
pub type __socklen_t = ::std::os::raw::c_uint;
pub type __sig_atomic_t = ::std::os::raw::c_int;
pub type int_least8_t = __int_least8_t;
pub type int_least16_t = __int_least16_t;
pub type int_least32_t = __int_least32_t;
pub type int_least64_t = __int_least64_t;
pub type uint_least8_t = __uint_least8_t;
pub type uint_least16_t = __uint_least16_t;
pub type uint_least32_t = __uint_least32_t;
pub type uint_least64_t = __uint_least64_t;
pub type int_fast8_t = ::std::os::raw::c_schar;
pub type int_fast16_t = ::std::os::raw::c_long;
pub type int_fast32_t = ::std::os::raw::c_long;
pub type int_fast64_t = ::std::os::raw::c_long;
pub type uint_fast8_t = ::std::os::raw::c_uchar;
pub type uint_fast16_t = ::std::os::raw::c_ulong;
pub type uint_fast32_t = ::std::os::raw::c_ulong;
pub type uint_fast64_t = ::std::os::raw::c_ulong;
pub type intmax_t = __intmax_t;
pub type uintmax_t = __uintmax_t;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pod5FileReader {
    _unused: [u8; 0],
}
pub type Pod5FileReader_t = Pod5FileReader;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pod5FileWriter {
    _unused: [u8; 0],
}
pub type Pod5FileWriter_t = Pod5FileWriter;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pod5ReadRecordBatch {
    _unused: [u8; 0],
}
pub type Pod5ReadRecordBatch_t = Pod5ReadRecordBatch;
pub const pod5_error_POD5_OK: pod5_error = 0;
pub const pod5_error_POD5_ERROR_OUTOFMEMORY: pod5_error = 1;
pub const pod5_error_POD5_ERROR_KEYERROR: pod5_error = 2;
pub const pod5_error_POD5_ERROR_TYPEERROR: pod5_error = 3;
pub const pod5_error_POD5_ERROR_INVALID: pod5_error = 4;
pub const pod5_error_POD5_ERROR_IOERROR: pod5_error = 5;
pub const pod5_error_POD5_ERROR_CAPACITYERROR: pod5_error = 6;
pub const pod5_error_POD5_ERROR_INDEXERROR: pod5_error = 7;
pub const pod5_error_POD5_ERROR_CANCELLED: pod5_error = 8;
pub const pod5_error_POD5_ERROR_UNKNOWNERROR: pod5_error = 9;
pub const pod5_error_POD5_ERROR_NOTIMPLEMENTED: pod5_error = 10;
pub const pod5_error_POD5_ERROR_SERIALIZATIONERROR: pod5_error = 11;
pub const pod5_error_POD5_ERROR_STRING_NOT_LONG_ENOUGH: pod5_error = 12;
/** \brief Integer error codes.
 \note Taken from the arrow status enum.*/
pub type pod5_error = ::std::os::raw::c_uint;
/** \brief Integer error codes.
 \note Taken from the arrow status enum.*/
pub use self::pod5_error as pod5_error_t;
extern "C" {
    /// \brief Get the most recent error number from all pod5 api's.
    pub fn pod5_get_error_no() -> pod5_error_t;
}
extern "C" {
    /** \brief Get the most recent error description string from all pod5 api's.
 \note The string's lifetime is internally managed, a caller should not free it.*/
    pub fn pod5_get_error_string() -> *const ::std::os::raw::c_char;
}
extern "C" {
    /// \brief Initialise and register global pod5 types
    pub fn pod5_init() -> pod5_error_t;
}
extern "C" {
    /// \brief Terminate global pod5 types
    pub fn pod5_terminate() -> pod5_error_t;
}
pub const pod5_end_reason_POD5_END_REASON_UNKNOWN: pod5_end_reason = 0;
pub const pod5_end_reason_POD5_END_REASON_MUX_CHANGE: pod5_end_reason = 1;
pub const pod5_end_reason_POD5_END_REASON_UNBLOCK_MUX_CHANGE: pod5_end_reason = 2;
pub const pod5_end_reason_POD5_END_REASON_DATA_SERVICE_UNBLOCK_MUX_CHANGE: pod5_end_reason = 3;
pub const pod5_end_reason_POD5_END_REASON_SIGNAL_POSITIVE: pod5_end_reason = 4;
pub const pod5_end_reason_POD5_END_REASON_SIGNAL_NEGATIVE: pod5_end_reason = 5;
pub const pod5_end_reason_POD5_END_REASON_API_REQUEST: pod5_end_reason = 6;
pub const pod5_end_reason_POD5_END_REASON_DEVICE_DATA_ERROR: pod5_end_reason = 7;
pub const pod5_end_reason_POD5_END_REASON_ANALYSIS_CONFIG_CHANGE: pod5_end_reason = 8;
pub type pod5_end_reason = ::std::os::raw::c_uint;
pub use self::pod5_end_reason as pod5_end_reason_t;
pub type run_info_index_t = u16;
pub type read_id_t = [u8; 16usize];
pub type run_id_t = [u8; 16usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReadBatchRowInfoV3 {
    pub read_id: read_id_t,
    pub read_number: u32,
    pub start_sample: u64,
    pub median_before: f32,
    pub channel: u16,
    pub well: u8,
    pub pore_type: i16,
    pub calibration_offset: f32,
    pub calibration_scale: f32,
    pub end_reason: i16,
    pub end_reason_forced: u8,
    pub run_info: i16,
    pub num_minknow_events: u64,
    pub tracked_scaling_scale: f32,
    pub tracked_scaling_shift: f32,
    pub predicted_scaling_scale: f32,
    pub predicted_scaling_shift: f32,
    pub num_reads_since_mux_change: u32,
    pub time_since_mux_change: f32,
    pub signal_row_count: i64,
    pub num_samples: u64,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of ReadBatchRowInfoV3",
    ][::std::mem::size_of::<ReadBatchRowInfoV3>() - 112usize];
    [
        "Alignment of ReadBatchRowInfoV3",
    ][::std::mem::align_of::<ReadBatchRowInfoV3>() - 8usize];
    [
        "Offset of field: ReadBatchRowInfoV3::read_id",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, read_id) - 0usize];
    [
        "Offset of field: ReadBatchRowInfoV3::read_number",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, read_number) - 16usize];
    [
        "Offset of field: ReadBatchRowInfoV3::start_sample",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, start_sample) - 24usize];
    [
        "Offset of field: ReadBatchRowInfoV3::median_before",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, median_before) - 32usize];
    [
        "Offset of field: ReadBatchRowInfoV3::channel",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, channel) - 36usize];
    [
        "Offset of field: ReadBatchRowInfoV3::well",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, well) - 38usize];
    [
        "Offset of field: ReadBatchRowInfoV3::pore_type",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, pore_type) - 40usize];
    [
        "Offset of field: ReadBatchRowInfoV3::calibration_offset",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, calibration_offset) - 44usize];
    [
        "Offset of field: ReadBatchRowInfoV3::calibration_scale",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, calibration_scale) - 48usize];
    [
        "Offset of field: ReadBatchRowInfoV3::end_reason",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, end_reason) - 52usize];
    [
        "Offset of field: ReadBatchRowInfoV3::end_reason_forced",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, end_reason_forced) - 54usize];
    [
        "Offset of field: ReadBatchRowInfoV3::run_info",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, run_info) - 56usize];
    [
        "Offset of field: ReadBatchRowInfoV3::num_minknow_events",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, num_minknow_events) - 64usize];
    [
        "Offset of field: ReadBatchRowInfoV3::tracked_scaling_scale",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, tracked_scaling_scale) - 72usize];
    [
        "Offset of field: ReadBatchRowInfoV3::tracked_scaling_shift",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, tracked_scaling_shift) - 76usize];
    [
        "Offset of field: ReadBatchRowInfoV3::predicted_scaling_scale",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, predicted_scaling_scale) - 80usize];
    [
        "Offset of field: ReadBatchRowInfoV3::predicted_scaling_shift",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, predicted_scaling_shift) - 84usize];
    [
        "Offset of field: ReadBatchRowInfoV3::num_reads_since_mux_change",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, num_reads_since_mux_change) - 88usize];
    [
        "Offset of field: ReadBatchRowInfoV3::time_since_mux_change",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, time_since_mux_change) - 92usize];
    [
        "Offset of field: ReadBatchRowInfoV3::signal_row_count",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, signal_row_count) - 96usize];
    [
        "Offset of field: ReadBatchRowInfoV3::num_samples",
    ][::std::mem::offset_of!(ReadBatchRowInfoV3, num_samples) - 104usize];
};
pub type ReadBatchRowInfo_t = ReadBatchRowInfoV3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct ReadBatchRowInfoArrayV3 {
    pub read_id: *const read_id_t,
    pub read_number: *const u32,
    pub start_sample: *const u64,
    pub median_before: *const f32,
    pub channel: *const u16,
    pub well: *const u8,
    pub pore_type: *const i16,
    pub calibration_offset: *const f32,
    pub calibration_scale: *const f32,
    pub end_reason: *const pod5_end_reason_t,
    pub end_reason_forced: *const u8,
    pub run_info_id: *const i16,
    pub num_minknow_events: *const u64,
    pub tracked_scaling_scale: *const f32,
    pub tracked_scaling_shift: *const f32,
    pub predicted_scaling_scale: *const f32,
    pub predicted_scaling_shift: *const f32,
    pub num_reads_since_mux_change: *const u32,
    pub time_since_mux_change: *const f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of ReadBatchRowInfoArrayV3",
    ][::std::mem::size_of::<ReadBatchRowInfoArrayV3>() - 152usize];
    [
        "Alignment of ReadBatchRowInfoArrayV3",
    ][::std::mem::align_of::<ReadBatchRowInfoArrayV3>() - 8usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::read_id",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, read_id) - 0usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::read_number",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, read_number) - 8usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::start_sample",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, start_sample) - 16usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::median_before",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, median_before) - 24usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::channel",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, channel) - 32usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::well",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, well) - 40usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::pore_type",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, pore_type) - 48usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::calibration_offset",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, calibration_offset) - 56usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::calibration_scale",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, calibration_scale) - 64usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::end_reason",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, end_reason) - 72usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::end_reason_forced",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, end_reason_forced) - 80usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::run_info_id",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, run_info_id) - 88usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::num_minknow_events",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, num_minknow_events) - 96usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::tracked_scaling_scale",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, tracked_scaling_scale) - 104usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::tracked_scaling_shift",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, tracked_scaling_shift) - 112usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::predicted_scaling_scale",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, predicted_scaling_scale)
        - 120usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::predicted_scaling_shift",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, predicted_scaling_shift)
        - 128usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::num_reads_since_mux_change",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, num_reads_since_mux_change)
        - 136usize];
    [
        "Offset of field: ReadBatchRowInfoArrayV3::time_since_mux_change",
    ][::std::mem::offset_of!(ReadBatchRowInfoArrayV3, time_since_mux_change) - 144usize];
};
pub type ReadBatchRowInfoArray_t = ReadBatchRowInfoArrayV3;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pod5ReaderOptions {
    /** \brief Disable file mapping into memory. Reduces memory usage of pod5 files, at the expense
        of the underlying arrow file loading into memory on demand.*/
    pub force_disable_file_mapping: ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Pod5ReaderOptions"][::std::mem::size_of::<Pod5ReaderOptions>() - 1usize];
    [
        "Alignment of Pod5ReaderOptions",
    ][::std::mem::align_of::<Pod5ReaderOptions>() - 1usize];
    [
        "Offset of field: Pod5ReaderOptions::force_disable_file_mapping",
    ][::std::mem::offset_of!(Pod5ReaderOptions, force_disable_file_mapping) - 0usize];
};
pub type Pod5ReaderOptions_t = Pod5ReaderOptions;
extern "C" {
    /** \brief Open a file reader
 \param filename         The filename of the pod5 file.
 \see             pod5_open_file_options*/
    pub fn pod5_open_file(
        filename: *const ::std::os::raw::c_char,
    ) -> *mut Pod5FileReader_t;
}
extern "C" {
    /** \brief Open a file reader
 \param filename         The filename of the pod5 file.
 \param options          The options to use when opening the file.*/
    pub fn pod5_open_file_options(
        filename: *const ::std::os::raw::c_char,
        options: *const Pod5ReaderOptions_t,
    ) -> *mut Pod5FileReader_t;
}
extern "C" {
    /// \brief Close a file reader, releasing all memory held by the reader.
    pub fn pod5_close_and_free_reader(file: *mut Pod5FileReader_t) -> pod5_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileInfo {
    pub file_identifier: read_id_t,
    pub version: FileInfo_Version,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct FileInfo_Version {
    pub major: u16,
    pub minor: u16,
    pub revision: u16,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FileInfo_Version"][::std::mem::size_of::<FileInfo_Version>() - 6usize];
    [
        "Alignment of FileInfo_Version",
    ][::std::mem::align_of::<FileInfo_Version>() - 2usize];
    [
        "Offset of field: FileInfo_Version::major",
    ][::std::mem::offset_of!(FileInfo_Version, major) - 0usize];
    [
        "Offset of field: FileInfo_Version::minor",
    ][::std::mem::offset_of!(FileInfo_Version, minor) - 2usize];
    [
        "Offset of field: FileInfo_Version::revision",
    ][::std::mem::offset_of!(FileInfo_Version, revision) - 4usize];
};
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of FileInfo"][::std::mem::size_of::<FileInfo>() - 22usize];
    ["Alignment of FileInfo"][::std::mem::align_of::<FileInfo>() - 2usize];
    [
        "Offset of field: FileInfo::file_identifier",
    ][::std::mem::offset_of!(FileInfo, file_identifier) - 0usize];
    [
        "Offset of field: FileInfo::version",
    ][::std::mem::offset_of!(FileInfo, version) - 16usize];
};
pub type FileInfo_t = FileInfo;
extern "C" {
    /** \brief Find info about a file.
 \param[out] file        The file to be queried.
 \param      file_info   The info read from the file.*/
    pub fn pod5_get_file_info(
        file: *mut Pod5FileReader_t,
        file_info: *mut FileInfo_t,
    ) -> pod5_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EmbeddedFileData {
    pub file_name: *const ::std::os::raw::c_char,
    pub offset: usize,
    pub length: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of EmbeddedFileData"][::std::mem::size_of::<EmbeddedFileData>() - 24usize];
    [
        "Alignment of EmbeddedFileData",
    ][::std::mem::align_of::<EmbeddedFileData>() - 8usize];
    [
        "Offset of field: EmbeddedFileData::file_name",
    ][::std::mem::offset_of!(EmbeddedFileData, file_name) - 0usize];
    [
        "Offset of field: EmbeddedFileData::offset",
    ][::std::mem::offset_of!(EmbeddedFileData, offset) - 8usize];
    [
        "Offset of field: EmbeddedFileData::length",
    ][::std::mem::offset_of!(EmbeddedFileData, length) - 16usize];
};
pub type EmbeddedFileData_t = EmbeddedFileData;
extern "C" {
    /** \brief Find the location of the read table data
 \param[out] file        The file to be queried.
 \param      file_data   The output read table file data.*/
    pub fn pod5_get_file_read_table_location(
        file: *mut Pod5FileReader_t,
        file_data: *mut EmbeddedFileData_t,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the location of the signal table data
 \param[out] file        The file to be queried.
 \param      file_data   The output signal table file data.*/
    pub fn pod5_get_file_signal_table_location(
        file: *mut Pod5FileReader_t,
        file_data: *mut EmbeddedFileData_t,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the location of the run info table data
 \param[out] file        The file to be queried.
 \param      file_data   The output signal table file data.*/
    pub fn pod5_get_file_run_info_table_location(
        file: *mut Pod5FileReader_t,
        file_data: *mut EmbeddedFileData_t,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the number of reads in the file.
 \param      reader  The file reader to read from
 \param[out] count   The number of reads in the file*/
    pub fn pod5_get_read_count(
        reader: *mut Pod5FileReader_t,
        count: *mut usize,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Grab the read_id's from the file.
 \param        reader        The file reader to read from.
 \param        count         The number of read_id's allocated in [read_ids], an error is raised if the count is not greater or equal to pod5_get_read_count.
 \param[out]   read_ids      The read id's written in a contiguous array.*/
    pub fn pod5_get_read_ids(
        reader: *mut Pod5FileReader_t,
        count: usize,
        read_ids: *mut read_id_t,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Plan the most efficient route through the data for the given read ids
 \param      file                The file to be queried.
 \param      read_id_array       The read id array (contiguous array, 16 bytes per id).
 \param      read_id_count       The number of read ids.
 \param[out] batch_counts        The number of rows per batch that need to be visited (rows listed in batch_rows),
                                 input array length should be the number of read table batches.
 \param[out] batch_rows          Rows to visit per batch, packed into one array. Offsets into this array from
                                 [batch_counts] provide the per-batch row data. Input array length should
                                 equal read_id_count.
 \param[out] find_success_count  The number of requested read ids that were found.
 \note The output array is sorted in file storage order, to improve read efficiency.
       [find_success_count] is the number of successful find steps in the result [steps].
       Failed finds are all sorted to the back of the [steps] array, and are marked with an
       invalid batch and batch_row value.*/
    pub fn pod5_plan_traversal(
        file: *mut Pod5FileReader_t,
        read_id_array: *const u8,
        read_id_count: usize,
        batch_counts: *mut u32,
        batch_rows: *mut u32,
        find_success_count: *mut usize,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the number of read batches in the file.
 \param[out] count   The number of read batches in the file
 \param      reader  The file reader to read from*/
    pub fn pod5_get_read_batch_count(
        count: *mut usize,
        reader: *mut Pod5FileReader_t,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Get a read batch from the file.
 \param[out] batch   The extracted batch.
 \param      reader  The file reader to read from
 \param      index   The index of the batch to read.
 \note Batches returned from this API must be freed using #pod5_free_read_batch*/
    pub fn pod5_get_read_batch(
        batch: *mut *mut Pod5ReadRecordBatch_t,
        reader: *mut Pod5FileReader_t,
        index: usize,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Release a read batch when it is not longer used.
 \param batch The batch to release.*/
    pub fn pod5_free_read_batch(batch: *mut Pod5ReadRecordBatch_t) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the number of rows in a batch.
 \param[out] count   The number of rows in the batch.
 \param      batch   The batch to query the number of rows for.*/
    pub fn pod5_get_read_batch_row_count(
        count: *mut usize,
        batch: *mut Pod5ReadRecordBatch_t,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the info for a row in a read batch.
 \param      batch               The read batch to query.
 \param      row                 The row index to query.
 \param      struct_version      The version of the struct being passed in, calling code
                                 should use [READ_BATCH_ROW_INFO_VERSION].
 \param[out] row_data            The data for reading into, should be a pointer to ReadBatchRowInfo_t.
 \param[out] read_table_version  The table version read from the file, will indicate which fields should be available.
                                 See READ_BATCH_ROW_INFO_VERSION and ReadBatchRowInfo_t above for corresponding fields.*/
    pub fn pod5_get_read_batch_row_info_data(
        batch: *mut Pod5ReadRecordBatch_t,
        row: usize,
        struct_version: u16,
        row_data: *mut ::std::os::raw::c_void,
        read_table_version: *mut u16,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the signal indices for a row in a read batch.
 \param      batch                       The read batch to query.
 \param      row                         The row index to query.
 \param      signal_row_indices_count    Number of entries in the signal_row_indices array.
 \param[out] signal_row_indices          The signal row indices read out of the read row.
 \note signal_row_indices_count Must equal signal_row_count returned from pod5_get_read_batch_row_info_data
       or an error is generated.*/
    pub fn pod5_get_signal_row_indices(
        batch: *mut Pod5ReadRecordBatch_t,
        row: usize,
        signal_row_indices_count: i64,
        signal_row_indices: *mut u64,
    ) -> pod5_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct CalibrationExtraData {
    pub digitisation: u16,
    pub range: f32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    [
        "Size of CalibrationExtraData",
    ][::std::mem::size_of::<CalibrationExtraData>() - 8usize];
    [
        "Alignment of CalibrationExtraData",
    ][::std::mem::align_of::<CalibrationExtraData>() - 4usize];
    [
        "Offset of field: CalibrationExtraData::digitisation",
    ][::std::mem::offset_of!(CalibrationExtraData, digitisation) - 0usize];
    [
        "Offset of field: CalibrationExtraData::range",
    ][::std::mem::offset_of!(CalibrationExtraData, range) - 4usize];
};
pub type CalibrationExtraData_t = CalibrationExtraData;
extern "C" {
    /** \brief Find the extra calibration info for a row in a read batch.
 \param      batch                   The read batch to query.
 \param      row                     The read row index.
 \param[out] calibration_extra_data  Output location for the calibration data.
 \note The values are computed from data held in the file, and written directly to the address provided, there is no need to release any data.*/
    pub fn pod5_get_calibration_extra_info(
        batch: *mut Pod5ReadRecordBatch_t,
        row: usize,
        calibration_extra_data: *mut CalibrationExtraData_t,
    ) -> pod5_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct KeyValueData {
    pub size: usize,
    pub keys: *mut *const ::std::os::raw::c_char,
    pub values: *mut *const ::std::os::raw::c_char,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of KeyValueData"][::std::mem::size_of::<KeyValueData>() - 24usize];
    ["Alignment of KeyValueData"][::std::mem::align_of::<KeyValueData>() - 8usize];
    [
        "Offset of field: KeyValueData::size",
    ][::std::mem::offset_of!(KeyValueData, size) - 0usize];
    [
        "Offset of field: KeyValueData::keys",
    ][::std::mem::offset_of!(KeyValueData, keys) - 8usize];
    [
        "Offset of field: KeyValueData::values",
    ][::std::mem::offset_of!(KeyValueData, values) - 16usize];
};
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct RunInfoDictData {
    pub acquisition_id: *const ::std::os::raw::c_char,
    pub acquisition_start_time_ms: i64,
    pub adc_max: i16,
    pub adc_min: i16,
    pub context_tags: KeyValueData,
    pub experiment_name: *const ::std::os::raw::c_char,
    pub flow_cell_id: *const ::std::os::raw::c_char,
    pub flow_cell_product_code: *const ::std::os::raw::c_char,
    pub protocol_name: *const ::std::os::raw::c_char,
    pub protocol_run_id: *const ::std::os::raw::c_char,
    pub protocol_start_time_ms: i64,
    pub sample_id: *const ::std::os::raw::c_char,
    pub sample_rate: u16,
    pub sequencing_kit: *const ::std::os::raw::c_char,
    pub sequencer_position: *const ::std::os::raw::c_char,
    pub sequencer_position_type: *const ::std::os::raw::c_char,
    pub software: *const ::std::os::raw::c_char,
    pub system_name: *const ::std::os::raw::c_char,
    pub system_type: *const ::std::os::raw::c_char,
    pub tracking_id: KeyValueData,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of RunInfoDictData"][::std::mem::size_of::<RunInfoDictData>() - 184usize];
    ["Alignment of RunInfoDictData"][::std::mem::align_of::<RunInfoDictData>() - 8usize];
    [
        "Offset of field: RunInfoDictData::acquisition_id",
    ][::std::mem::offset_of!(RunInfoDictData, acquisition_id) - 0usize];
    [
        "Offset of field: RunInfoDictData::acquisition_start_time_ms",
    ][::std::mem::offset_of!(RunInfoDictData, acquisition_start_time_ms) - 8usize];
    [
        "Offset of field: RunInfoDictData::adc_max",
    ][::std::mem::offset_of!(RunInfoDictData, adc_max) - 16usize];
    [
        "Offset of field: RunInfoDictData::adc_min",
    ][::std::mem::offset_of!(RunInfoDictData, adc_min) - 18usize];
    [
        "Offset of field: RunInfoDictData::context_tags",
    ][::std::mem::offset_of!(RunInfoDictData, context_tags) - 24usize];
    [
        "Offset of field: RunInfoDictData::experiment_name",
    ][::std::mem::offset_of!(RunInfoDictData, experiment_name) - 48usize];
    [
        "Offset of field: RunInfoDictData::flow_cell_id",
    ][::std::mem::offset_of!(RunInfoDictData, flow_cell_id) - 56usize];
    [
        "Offset of field: RunInfoDictData::flow_cell_product_code",
    ][::std::mem::offset_of!(RunInfoDictData, flow_cell_product_code) - 64usize];
    [
        "Offset of field: RunInfoDictData::protocol_name",
    ][::std::mem::offset_of!(RunInfoDictData, protocol_name) - 72usize];
    [
        "Offset of field: RunInfoDictData::protocol_run_id",
    ][::std::mem::offset_of!(RunInfoDictData, protocol_run_id) - 80usize];
    [
        "Offset of field: RunInfoDictData::protocol_start_time_ms",
    ][::std::mem::offset_of!(RunInfoDictData, protocol_start_time_ms) - 88usize];
    [
        "Offset of field: RunInfoDictData::sample_id",
    ][::std::mem::offset_of!(RunInfoDictData, sample_id) - 96usize];
    [
        "Offset of field: RunInfoDictData::sample_rate",
    ][::std::mem::offset_of!(RunInfoDictData, sample_rate) - 104usize];
    [
        "Offset of field: RunInfoDictData::sequencing_kit",
    ][::std::mem::offset_of!(RunInfoDictData, sequencing_kit) - 112usize];
    [
        "Offset of field: RunInfoDictData::sequencer_position",
    ][::std::mem::offset_of!(RunInfoDictData, sequencer_position) - 120usize];
    [
        "Offset of field: RunInfoDictData::sequencer_position_type",
    ][::std::mem::offset_of!(RunInfoDictData, sequencer_position_type) - 128usize];
    [
        "Offset of field: RunInfoDictData::software",
    ][::std::mem::offset_of!(RunInfoDictData, software) - 136usize];
    [
        "Offset of field: RunInfoDictData::system_name",
    ][::std::mem::offset_of!(RunInfoDictData, system_name) - 144usize];
    [
        "Offset of field: RunInfoDictData::system_type",
    ][::std::mem::offset_of!(RunInfoDictData, system_type) - 152usize];
    [
        "Offset of field: RunInfoDictData::tracking_id",
    ][::std::mem::offset_of!(RunInfoDictData, tracking_id) - 160usize];
};
pub type RunInfoDictData_t = RunInfoDictData;
extern "C" {
    /** \brief Find the run info for a row in a read batch.
 \param      batch               The read batch to query.
 \param      run_info            The run info index to query from the passed batch.
 \param[out] run_info_data       Output location for the run info data.
 \note The returned run_info value should be released using pod5_free_run_info when it is no longer used.*/
    pub fn pod5_get_run_info(
        batch: *mut Pod5ReadRecordBatch_t,
        run_info: i16,
        run_info_data: *mut *mut RunInfoDictData_t,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the run info for a row in a file.
 \param      file                The file to query.
 \param      run_info_index      The run info index to query from the passed file.
 \param[out] run_info_data       Output location for the run info data.
 \note The returned run_info value should be released using pod5_free_run_info when it is no longer used.*/
    pub fn pod5_get_file_run_info(
        file: *mut Pod5FileReader_t,
        run_info_index: run_info_index_t,
        run_info_data: *mut *mut RunInfoDictData_t,
    ) -> pod5_error_t;
}
extern "C" {
    /// \brief Release a RunInfoDictData struct after use.
    pub fn pod5_free_run_info(run_info_data: *mut RunInfoDictData_t) -> pod5_error_t;
}
extern "C" {
    /** \brief Release a RunInfoDictData struct after use.
 \deprecated*/
    pub fn pod5_release_run_info(run_info_data: *mut RunInfoDictData_t) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the run info for a row in a read file.
 \param      file                The file to query.
 \param[out] run_info_count      The number of run info's that are present in they queried file*/
    pub fn pod5_get_file_run_info_count(
        file: *mut Pod5FileReader_t,
        run_info_count: *mut run_info_index_t,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the end reason for a row in a read batch.
 \param          batch                           The read batch to query.
 \param          end_reason                      The end reason index to query from the passed batch.
 \param          end_reason_value                The enum value for end reason.
 \param[out]     end_reason_string_value         Output location for the string value for the end reason.
 \param[in,out]  end_reason_string_value_size    Size of [end_reason_string_value], the number of characters written (including 1 for null character) is placed in this value on return.
 \note If the string input is not long enough POD5_ERROR_STRING_NOT_LONG_ENOUGH is returned.*/
    pub fn pod5_get_end_reason(
        batch: *mut Pod5ReadRecordBatch_t,
        end_reason: i16,
        end_reason_value: *mut pod5_end_reason_t,
        end_reason_string_value: *mut ::std::os::raw::c_char,
        end_reason_string_value_size: *mut usize,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the pore type for a row in a read batch.
 \param          batch                           The read batch to query.
 \param          pore_type                       The pore type index to query from the passed batch.
 \param[out]     pore_type_string_value          Output location for the string value for the pore type.
 \param[in,out]  pore_type_string_value_size     Size of [pore_type_string_value], the number of characters written (including 1 for null character) is placed in this value on return.
 \note If the string input is not long enough POD5_ERROR_STRING_NOT_LONG_ENOUGH is returned.*/
    pub fn pod5_get_pore_type(
        batch: *mut Pod5ReadRecordBatch_t,
        pore_type: i16,
        pore_type_string_value: *mut ::std::os::raw::c_char,
        pore_type_string_value_size: *mut usize,
    ) -> pod5_error_t;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct SignalRowInfo {
    pub batch_index: usize,
    pub batch_row_index: usize,
    pub stored_sample_count: u32,
    pub stored_byte_count: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of SignalRowInfo"][::std::mem::size_of::<SignalRowInfo>() - 32usize];
    ["Alignment of SignalRowInfo"][::std::mem::align_of::<SignalRowInfo>() - 8usize];
    [
        "Offset of field: SignalRowInfo::batch_index",
    ][::std::mem::offset_of!(SignalRowInfo, batch_index) - 0usize];
    [
        "Offset of field: SignalRowInfo::batch_row_index",
    ][::std::mem::offset_of!(SignalRowInfo, batch_row_index) - 8usize];
    [
        "Offset of field: SignalRowInfo::stored_sample_count",
    ][::std::mem::offset_of!(SignalRowInfo, stored_sample_count) - 16usize];
    [
        "Offset of field: SignalRowInfo::stored_byte_count",
    ][::std::mem::offset_of!(SignalRowInfo, stored_byte_count) - 24usize];
};
pub type SignalRowInfo_t = SignalRowInfo;
extern "C" {
    /** \brief Find the info for a signal row in a reader.
 \param      reader                      The reader to query.
 \param      signal_rows_count           The number of signal rows to query.
 \param      signal_rows                 The signal rows to query.
 \param[out] signal_row_info             Pointers to the output signal row information (must be an array of size signal_rows_count)*/
    pub fn pod5_get_signal_row_info(
        reader: *mut Pod5FileReader_t,
        signal_rows_count: usize,
        signal_rows: *mut u64,
        signal_row_info: *mut *mut SignalRowInfo_t,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Release a list of signal row infos allocated by [pod5_get_signal_row_info].
 \param      signal_rows_count           The number of signal rows to release.
 \param      signal_row_info             The signal row infos to release.
 \note Calls to pod5_free_signal_row_info must be 1:1 with [pod5_get_signal_row_info], you cannot free part of the returned data.*/
    pub fn pod5_free_signal_row_info(
        signal_rows_count: usize,
        signal_row_info: *mut *mut SignalRowInfo_t,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the info for a signal row in a reader.
 \param      reader          The reader to query.
 \param      row_info        The signal row info batch index to query data for.
 \param      sample_count    The number of samples allocated in [sample_data] (must equal the length of signal data in the row).
 \param[out] sample_data     The output location for the queried samples.
 \note The signal data is allocated by the caller and should be released as appropriate by the caller.
 \todo MAJOR_VERSION Rename to include "chunk" or "row" or similar to indicate this gets only part of read signal.*/
    pub fn pod5_get_signal(
        reader: *mut Pod5FileReader_t,
        row_info: *mut SignalRowInfo_t,
        sample_count: usize,
        sample_data: *mut i16,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the sample count for a full read.
 \param      reader          The reader to query.
 \param      batch           The read batch to query.
 \param      batch_row       The read row to query data for.
 \param[out] sample_count    The number of samples in the read - including all chunks of raw data.*/
    pub fn pod5_get_read_complete_sample_count(
        reader: *mut Pod5FileReader_t,
        batch: *mut Pod5ReadRecordBatch_t,
        batch_row: usize,
        sample_count: *mut usize,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the signal for a full read.
 \param      reader          The reader to query.
 \param      batch           The read batch to query.
 \param      batch_row       The read row to query data for.
 \param      sample_count    The number of samples allocated in [signal] (must equal the length of signal data in the queryied read row).
 \param[out] signal          The output location for the queried samples.
 \note The signal data is allocated by the caller and should be released as appropriate by the caller.*/
    pub fn pod5_get_read_complete_signal(
        reader: *mut Pod5FileReader_t,
        batch: *mut Pod5ReadRecordBatch_t,
        batch_row: usize,
        sample_count: usize,
        signal: *mut i16,
    ) -> pod5_error_t;
}
/// \brief Use the default signal compression option.
pub const CompressionOption_DEFAULT_SIGNAL_COMPRESSION: CompressionOption = 0;
/// \brief Use vbz to compress read signals in tables.
pub const CompressionOption_VBZ_SIGNAL_COMPRESSION: CompressionOption = 1;
/// \brief Write signals uncompressed to tables.
pub const CompressionOption_UNCOMPRESSED_SIGNAL: CompressionOption = 2;
pub type CompressionOption = ::std::os::raw::c_uint;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Pod5WriterOptions {
    /** \brief Maximum number of samples to place in one signal record in the signals table.
 \note Use zero to use default value.*/
    pub max_signal_chunk_size: u32,
    /** \brief Signal type to write to the signals table.
 \note Use 'DEFAULT_SIGNAL_COMPRESSION' to use default value.*/
    pub signal_compression_type: i8,
    /// \brief The size of each batch written for the signal table (zero for default).
    pub signal_table_batch_size: usize,
    /// \brief The size of each batch written for the reads table (zero for default).
    pub read_table_batch_size: usize,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of Pod5WriterOptions"][::std::mem::size_of::<Pod5WriterOptions>() - 24usize];
    [
        "Alignment of Pod5WriterOptions",
    ][::std::mem::align_of::<Pod5WriterOptions>() - 8usize];
    [
        "Offset of field: Pod5WriterOptions::max_signal_chunk_size",
    ][::std::mem::offset_of!(Pod5WriterOptions, max_signal_chunk_size) - 0usize];
    [
        "Offset of field: Pod5WriterOptions::signal_compression_type",
    ][::std::mem::offset_of!(Pod5WriterOptions, signal_compression_type) - 4usize];
    [
        "Offset of field: Pod5WriterOptions::signal_table_batch_size",
    ][::std::mem::offset_of!(Pod5WriterOptions, signal_table_batch_size) - 8usize];
    [
        "Offset of field: Pod5WriterOptions::read_table_batch_size",
    ][::std::mem::offset_of!(Pod5WriterOptions, read_table_batch_size) - 16usize];
};
pub type Pod5WriterOptions_t = Pod5WriterOptions;
extern "C" {
    /** \brief Create a new pod5 file using specified filenames and options.
 \param filename         The filename of the pod5 file.
 \param writer_name      A descriptive string for the user software writing this file.
 \param options          Options controlling how the file will be written.*/
    pub fn pod5_create_file(
        filename: *const ::std::os::raw::c_char,
        writer_name: *const ::std::os::raw::c_char,
        options: *const Pod5WriterOptions_t,
    ) -> *mut Pod5FileWriter_t;
}
extern "C" {
    /// \brief Close a file writer, releasing all memory held by the writer.
    pub fn pod5_close_and_free_writer(file: *mut Pod5FileWriter_t) -> pod5_error_t;
}
extern "C" {
    /** \brief Add a new pore type to the file.
 \param[out] pore_index  The index of the added pore.
 \param      file        The file to add the new pore type to.
 \param      pore_type   The pore type string for the pore.*/
    pub fn pod5_add_pore(
        pore_index: *mut i16,
        file: *mut Pod5FileWriter_t,
        pore_type: *const ::std::os::raw::c_char,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Add a new run info to the file, containing tracking information about a sequencing run.
 \param[out] run_info_index              The index of the added run_info.
 \param      file                        The file to add the new pore type to.
 \param      acquisition_id              The offset parameter for the calibration.
 \param      acquisition_start_time_ms   Milliseconds after unix epoch when the acquisition was started.
 \param      adc_max                     Maximum ADC value supported by this hardware.
 \param      adc_min                     Minimum ADC value supported by this hardware.
 \param      context_tags_count          Number of entries in the context tags map.
 \param      context_tags_keys           Array of strings used as keys into the context tags map (must have context_tags_count entries).
 \param      context_tags_values         Array of strings used as values in the context tags map (must have context_tags_count entries).
 \param      experiment_name             Name given by the user to the group including this protocol.
 \param      flow_cell_id                Id for the flow cell used in the run.
 \param      flow_cell_product_code      Product code for the flow cell used in the run.
 \param      protocol_name               Name given by the user to the protocol.
 \param      protocol_run_id             Run id for the protocol.
 \param      protocol_start_time_ms      Milliseconds after unix epoch when the protocol was started.
 \param      sample_id                   Name given by the user for sample id.
 \param      sample_rate                 Sample rate of the run.
 \param      sequencing_kit              Sequencing kit used in the run.
 \param      sequencer_position          Sequencer position used in the run.
 \param      sequencer_position_type     Sequencer position type used in the run.
 \param      software                    Name of the software used to produce the run.
 \param      system_name                 Name of the system used to produce the run.
 \param      system_type                 Type of the system used to produce the run.
 \param      tracking_id_count           Number of entries in the tracking id map.
 \param      tracking_id_keys            Array of strings used as keys into the tracking id map (must have tracking_id_count entries).
 \param      tracking_id_values          Array of strings used as values in the tracking id map (must have tracking_id_count entries).*/
    pub fn pod5_add_run_info(
        run_info_index: *mut i16,
        file: *mut Pod5FileWriter_t,
        acquisition_id: *const ::std::os::raw::c_char,
        acquisition_start_time_ms: i64,
        adc_max: i16,
        adc_min: i16,
        context_tags_count: usize,
        context_tags_keys: *mut *const ::std::os::raw::c_char,
        context_tags_values: *mut *const ::std::os::raw::c_char,
        experiment_name: *const ::std::os::raw::c_char,
        flow_cell_id: *const ::std::os::raw::c_char,
        flow_cell_product_code: *const ::std::os::raw::c_char,
        protocol_name: *const ::std::os::raw::c_char,
        protocol_run_id: *const ::std::os::raw::c_char,
        protocol_start_time_ms: i64,
        sample_id: *const ::std::os::raw::c_char,
        sample_rate: u16,
        sequencing_kit: *const ::std::os::raw::c_char,
        sequencer_position: *const ::std::os::raw::c_char,
        sequencer_position_type: *const ::std::os::raw::c_char,
        software: *const ::std::os::raw::c_char,
        system_name: *const ::std::os::raw::c_char,
        system_type: *const ::std::os::raw::c_char,
        tracking_id_count: usize,
        tracking_id_keys: *mut *const ::std::os::raw::c_char,
        tracking_id_values: *mut *const ::std::os::raw::c_char,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Add a read to the file.

 For each read `r`, where `0 <= r < read_count`:
 - `((RowInfo_t const*)row_data)[r]` describes the read metadata, where `RowInfo_t` is determined by [struct_version]
 - `signal[r]` is the raw signal data for the read
 - `signal_size[r]` is the length of `signal[r]` (in samples, not in bytes)

 \param      file            The file to add the reads to.
 \param      read_count      The number of reads to add with this call.
 \param      struct_version  The version of the struct of [row_data] being filled, use READ_BATCH_ROW_INFO_VERSION.
 \param      row_data        The array data for injecting into the file, should be ReadBatchRowInfoArray_t.
                             This must be an array of length [read_count].
 \param      signal          The signal data for the reads.
 \param      signal_size     The number of samples in the signal data.
                             This must be an array of length [read_count].*/
    pub fn pod5_add_reads_data(
        file: *mut Pod5FileWriter_t,
        read_count: u32,
        struct_version: u16,
        row_data: *const ::std::os::raw::c_void,
        signal: *mut *const i16,
        signal_size: *const u32,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Add a read to the file, with pre compressed signal chunk sections.

 Consider using the simpler [pod5_add_reads_data] unless you have performance requirements that demand
 more control over compression and chunking.

 Data should be compressed using [pod5_vbz_compress_signal].

 For each read `r`, where `0 <= r < read_count`:
 - `((RowInfo_t const*)row_data)[r]` describes the read metadata, where `RowInfo_t` is determined by [struct_version]
 - `signal_chunk_count[r]` is the number of signal chunks
 - for each signal chunk `i` where `0 <= i < signal_chunk_count[r]`:
   - `sample_counts[r][i]` is the number of samples in the chunk (ie: the size of the uncompressed data in
     samples, not in bytes)
   - `compressed_signal[r][i]` is the compressed data
   - `compressed_signal_size[r][i]` is the length of the compressed data at `compressed_signal[r][i]`

 \param      file                    The file to add the read to.
 \param      read_count              The number of reads to add with this call.
 \param      struct_version          The version of the struct of [row_data] being filled, use READ_BATCH_ROW_INFO_VERSION.
 \param      row_data                The array data for injecting into the file, should be ReadBatchRowInfoArray_t.
                                     This must be an array of length [read_count].
 \param      compressed_signal       The signal chunks data for the read.
 \param      compressed_signal_size  The sizes (in bytes) of each signal chunk.
 \param      sample_counts           The number of samples of each signal chunk. In other words, it is the *uncompressed* size of the
                                     corresponding [compressed_signal] array, in samples (not bytes!).
 \param      signal_chunk_count      The number of sections of compressed signal.
                                     This must be an array of length [read_count].*/
    pub fn pod5_add_reads_data_pre_compressed(
        file: *mut Pod5FileWriter_t,
        read_count: u32,
        struct_version: u16,
        row_data: *const ::std::os::raw::c_void,
        compressed_signal: *mut *mut *const ::std::os::raw::c_char,
        compressed_signal_size: *mut *const usize,
        sample_counts: *mut *const u32,
        signal_chunk_count: *const usize,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Find the max size of a compressed array of samples.
 \param sample_count The number of samples in the source signal.
 \return The max number of bytes required for the compressed signal.*/
    pub fn pod5_vbz_compressed_signal_max_size(sample_count: usize) -> usize;
}
extern "C" {
    /** \brief VBZ compress an array of samples.
 \param          signal                      The signal to compress.
 \param          signal_size                 The number of samples to compress.
 \param[out]     compressed_signal_out       The compressed signal.
 \param[in,out]  compressed_signal_size      The number of compressed bytes, should be set to the size of compressed_signal_out on call.*/
    pub fn pod5_vbz_compress_signal(
        signal: *const i16,
        signal_size: usize,
        compressed_signal_out: *mut ::std::os::raw::c_char,
        compressed_signal_size: *mut usize,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief VBZ decompress an array of samples.
 \param          compressed_signal           The signal to decompress.
 \param          compressed_signal_size      The number of compressed bytes, ie the size of compressed_signal in bytes.
 \param          sample_count                The number of samples to decompress, ie the size of signal_out in samples.
 \param[out]     signal_out                  The decompressed signal.*/
    pub fn pod5_vbz_decompress_signal(
        compressed_signal: *const ::std::os::raw::c_char,
        compressed_signal_size: usize,
        sample_count: usize,
        signal_out: *mut i16,
    ) -> pod5_error_t;
}
extern "C" {
    /** \brief Format a packed binary read id as a readable read id string:
 \param          read_id           A 16 byte binary formatted UUID.
 \param[out]     read_id_string    Output string containing the string formatted UUID (expects a string of at least 37 bytes, one null byte is written.)*/
    pub fn pod5_format_read_id(
        read_id: *const u8,
        read_id_string: *mut ::std::os::raw::c_char,
    ) -> pod5_error_t;
}
